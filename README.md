# Air quality ðŸ˜·
This repository consists of several modules that together serves as an air quality monitoring system.

## Flow between services

![image](https://user-images.githubusercontent.com/16987380/44774916-a8b83280-ab74-11e8-93f0-cfcbc296805d.png)


## The different modules
Remember, certificates are needed to establish a connection to **Enlight Hierarchy**, **IoT** and **PAS**.

```
.
â”œâ”€â”€ aq_level
â”œâ”€â”€ build_hierarchy
â”œâ”€â”€ certs               <----
â”‚Â Â  â”œâ”€â”€ hierarchy
â”‚   â”‚   â”œâ”€â”€ ca.crt
â”‚   â”‚   â”œâ”€â”€ client.crt
â”‚   â”‚   â””â”€â”€ client.key
â”‚Â Â  â”œâ”€â”€ pas
â”‚   â”‚   â”œâ”€â”€ ca.crt
â”‚   â”‚   â”œâ”€â”€ client.crt
â”‚   â”‚   â””â”€â”€ client.key
â”‚Â Â  â””â”€â”€ iot
â”‚       â”œâ”€â”€ ca.crt
â”‚       â”œâ”€â”€ client.crt
â”‚       â””â”€â”€ client.key
â”œâ”€â”€ dashboard
â”œâ”€â”€ gen_config
â”œâ”€â”€ read_sensor
â””â”€â”€ vote
```
### `aq_level`
The air quality level module predicts the air quality into three different different categories which are either `Good`, `Ok` or `Bad`. This is done by listening to the **gRPC** stream from **Enlight IoT** and letting a *Deep Neural Network* (DNN) making a prediction every time all of the desired inspection points (values the **BME680** sensor reads) are updated.

The DNN is trained by manual labels which is a continuous process and these labels are fetched from the `vote` module.

### `build_hierarchy`
Generates an **Enlight hierarchy** based on the **RPi's** hostname. The generated inspection points are based on the data which is collectable from the **BME680** sensor. Thus temperature, humidity, pressure and volatile gases.  

### `dashboard`
The dashboard's backend reads the **gRPC** stream connected to **Enlight IoT**. It filters down and send *server-sent events* (sse) based on the given functional location and asset. The client side is built with react which gets this data from the go server using an EventSource.

### `gen_config`
This is meant to generate the required `config.json` file which is required by all of the other modules (see "flowchart" above).

### `read_sensor`
This module is meant to be running on a **RPi Zero W** with a **BME680** sensor attached. The script also supports backfilling data if the device loses internet connection.

### `vote`
Vote module consists of a client which is setup to send HTTP POST requests to an **AWS Lambda** which ingests the node data, generated by the user, to **Enlight IoT**. Voting on a specific asset is done by using the URL parameters `func_loc` and `asset`.

## Setup a new **RPi**
To configure a new **RPi** to automaticly read the sensor values on boot you'll need to use [PiBakery](http://www.pibakery.org/). There's currently a `pibakery.xml` located in the root of the repo, this is the recipie used to automaticly bootstrap the **RPi**.

Choosing host name on the **RPi** must follow the naming convention `functional_location-asset`, for an example, `install_team_room-cabinet`. This is done within PiBakery *Set host name to `functional_location-asset`*. The image below highlights the fields which needs to be manually configured.

![image](https://user-images.githubusercontent.com/16987380/44728832-a35bd900-aadd-11e8-8304-de39981d04c4.png)