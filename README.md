# Air quality
This repository consists of several modules that together serves as an air quality monitoring system.

## Flow between services

![image](https://user-images.githubusercontent.com/16987380/44730897-4b73a100-aae2-11e8-878d-33fe9b3d69db.png)

## The different modules
Remember, certificates are also needed to establish a connection to **Enlight Hierarchy**, **IoT** and **PAS**.

```
.
├── aq_level
├── build_hierarchy
├── certs               <----
│   ├── hierarchy
│   │   ├── ca.crt
│   │   ├── client.crt
│   │   └── client.key
│   ├── pas
│   │   ├── ca.crt
│   │   ├── client.crt
│   │   └── client.key
│   └── iot
│       ├── ca.crt
│       ├── client.crt
│       └── client.key
├── dashboard
├── gen_config
├── read_sensor
└── vote
```
### `aq-level`
The air quality level module predicts the air quality into three different different categories which are either `Good`, `Ok` or `Bad`. This is done by listening to the **gRPC** stream from **Enlight IoT** and letting a *Deep Neural Network* (DNN) making a prediction every time all of the desired inspection points (values the **BME680** sensor reads) are updated.

The DNN is trained by manual labels which is a continuous process and these labels are fetched from the `vote` module.

### `build_hierarchy`
Generates an **Enlight hierarchy** based on the RaspBerry Pi's hostname. The generated inspection points are based of the data which is collectable from the **BME680** sensor. Thus temperature, humidity, pressure and volatile gases.  

### `dashboard`
The dashboard's backend reads the **gRPC** stream connected to **Enlight IoT**. It filters down and send *server-sent events* (sse) based on the given functional location and asset. The client side is built with react which gets this data from the go server using an EventSource.

### `gen_config`
This is meant to generate the required `config.json` file which is required by all of the other modules (see "flowchart" above).

### `read_sensor`
This module is meant to be running on a **RPi Zero W** with a **BME680** sensor attached. The script also supports backfilling data if the device loses internet connection.

To configure a new **RPi** to automaticly read the sensor values on boot you'll need to use [PiBakery](http://www.pibakery.org/). There's currently a `pibakery.xml` located in the root of the repo, this is the recipie used to automaticly bootstrap the **RPi**.

Choosing host name on the **RPi** must follow the naming convention `functional_location-asset`, for an example, `install_team_room-cabinet`. This is done within PiBakery *Set host name to `functional_location-asset`*. The image below highlights the fields which needs to be manually configured.

![image](https://user-images.githubusercontent.com/16987380/44728832-a35bd900-aadd-11e8-8304-de39981d04c4.png)

### `vote`
Vote module consists of a client which is setup to send HTTP POST requests to an **AWS Lambda** which ingests the node data, generated by the user, to **Enlight IoT**. Voting on a specific asset is done by using the URL parameters `func_loc` and `asset`.
